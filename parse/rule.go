package parse

/*
Why BNF?
1. BNF is the minimal representation of context free grammars.
2. EBNF can be represented with BNF.
3. Loop is represented with recursive rule in BNF, while in EBNF it can be
   directly defined. However, recursive rule is still needed to represent
   grammars like infix expressions.

Rule naming
1. Nested rules are reduced as much as possible, but named rules are always kept.
2. An unnamed rule has a display name. If it is not recursive, its display name
   is its definition wrapped by parenthesis, otherwise, its display name is
   generated from its pointer address.
3. Rules generated by ZeroOrMore and OneOrMore are automatically named as r* and
   r+.
*/

type (
	// R is a BNF production rule
	R struct {
		name string
		Alts
		recursive bool
	}
	Alt struct {
		*R
		Rules
	}
	Rules []*R
	Alts  []*Alt
)

var (
	EOF  = Term("EOF")
	Null = Term("Null")
	self = Term("")
)

func newR() *R {
	return &R{}
}

func Term(name string) *R {
	r := newR()
	r.Alts = Alts{{R: r, Rules: Rules{nil}}}
	return r.As(name)
}

func (r *R) isTerm() bool {
	return len(r.Alts) == 1 && len(r.Alts[0].Rules) == 1 && r.Alts[0].Rules[0] == nil
}

func Rule(name string, rules ...*R) *R {
	r := Con(rules...)
	if r.name != "" {
		r = r.wrap()
	}
	r.initRecursiveRule(make(map[*R]bool), r)
	return r.As(name)
}
func (r *R) wrap() *R {
	nr := newR()
	nr.Alts = Alts{{R: nr, Rules: Rules{r}}}
	return nr
}
func (r *R) initRecursiveRule(m map[*R]bool, selfValue *R) {
	if r.isTerm() {
		return
	}
	if m[r] {
		r.recursive = true
		return
	}
	m[r] = true
	for _, alt := range r.Alts {
		if alt.R == self {
			alt.R = selfValue
		}
		for i, cr := range alt.Rules {
			if cr == self {
				alt.Rules[i] = selfValue
			} else {
				cr.initRecursiveRule(m, selfValue)
			}
		}
	}
}

func Self(name string) *R {
	self.name = name
	return self
}

func Con(rules ...*R) *R {
	if len(rules) == 1 {
		return rules[0]
	}
	r := newR()
	r.Alts = Alts{{r, rules}}
	return r
}

func Or(rules ...*R) *R {
	if len(rules) == 1 {
		return rules[0]
	}
	r := newR()
	r.Alts = make(Alts, len(rules))
	for i := range rules {
		r.Alts[i] = rules[i].toAlt(r)
	}
	return r
}
func (r *R) toAlt(parent *R) *Alt {
	if len(r.Alts) == 1 && r.name == "" { // reduce unnamed rule
		return &Alt{parent, r.Alts[0].Rules}
	}
	return &Alt{parent, Rules{r}}
}

func (r *R) As(name string) *R {
	r.name = name
	return r
}

func (r *R) ZeroOrOne() *R {
	return Or(r, Null)
}

func (r *R) OneOrMore() *R {
	return Con(r, r.ZeroOrMore()).As(r.Name() + "+")
}

func (r *R) ZeroOrMore() *R {
	x := newR()
	x.Alts = Or(Con(r, x), Null).toAlts(x)
	x.As(r.Name() + "*")
	return x
}
func (r *R) toAlts(parent *R) Alts {
	r.eachAlt(func(a *Alt) {
		a.R = parent
	})
	return r.Alts
}

func (r *R) isEOF() bool {
	return r == EOF
}

func (r *R) isNull() bool {
	return r == Null
}

func (r *R) eachAlt(visit func(a *Alt)) {
	for _, a := range r.Alts {
		visit(a)
	}
}

func (a *Alt) last() *R {
	if len(a.Rules) > 0 {
		return a.Rules[len(a.Rules)-1]
	}
	return nil
}

func (a *Alt) isNull() bool {
	return len(a.Rules) == 1 && a.Rules[0].isNull()
}

func (a *Alt) rule() *R {
	return a.R
}

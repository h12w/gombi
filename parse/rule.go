package parse

/*
Why BNF?
1. BNF is the minimal representation of context free grammars.
2. EBNF can be represented with BNF.
3. Loop is represented with recursive rule in BNF, while in EBNF it can be
   directly defined. However, recursive rule is still needed to represent
   grammars like infix expressions.

Rule naming
1. Nested rules are reduced as much as possible, but named rules are always kept.
2. An unnamed rule has a display name. If it is not recursive, its display name
   is its definition wrapped by parenthesis, otherwise, its display name is
   generated from its pointer address.
3. Rules generated by ZeroOrMore and OneOrMore are automatically named as r* and
   r+.
*/

type (
	// R is a BNF production rule
	R struct {
		name string
		Alts
		isTerm    bool
		recursive bool
	}
	Alt struct {
		*R
		Rules
	}
	Rules   []*R
	Alts    []*Alt
	Builder struct {
		terms map[string]*R
	}
)

var (
	EOF  = newTerm().As("EOF")
	Null = newTerm().As("Null")
	Self = newTerm()
)

func NewBuilder() *Builder {
	return &Builder{terms: make(map[string]*R)}
}

func newTerm() *R {
	r := &R{}
	r.isTerm = true
	r.Alts = Alts{{R: r}}
	return r
}

func NewRule() *R {
	return &R{}
}

func (b *Builder) Term(name string) *R {
	if r, ok := b.terms[name]; ok {
		return r
	}
	r := newTerm()
	r = r.As(name)
	b.terms[name] = r
	return r
}

//func Self(name string) *R {
//	self.name = name
//	return self
//}

func (b *Builder) toRules(a []interface{}) []*R {
	rs := make([]*R, len(a))
	for i := range rs {
		switch o := a[i].(type) {
		case *R:
			rs[i] = o
		case string:
			rs[i] = b.Term(o)
		default:
			panic("type of argument should be either string or *R")
		}
	}
	return rs
}

//func (r *R) isTerm() bool {
//	return len(r.Alts) == 1 && len(r.Alts[0].Rules) == 1 && r.Alts[0].Rules[0] == nil
//}

func (b *Builder) Recur(rules ...interface{}) *R {
	r := b.Con(rules...)
	if r.name != "" {
		r = r.wrap()
	}
	r.initRecursiveRule(make(map[*R]bool), r)
	return r
}

func (b *Builder) Rule(name string, rules ...interface{}) *R {
	return b.Recur(rules...).As(name)
}
func (r *R) wrap() *R {
	nr := NewRule()
	nr.Alts = Alts{{R: nr, Rules: Rules{r}}}
	return nr
}
func (r *R) initRecursiveRule(m map[*R]bool, selfValue *R) {
	if r.isTerm {
		return
	}
	if m[r] {
		r.recursive = true
		return
	}
	m[r] = true
	for _, alt := range r.Alts {
		if alt.R == Self {
			alt.R = selfValue
		}
		for i, cr := range alt.Rules {
			if cr == Self {
				alt.Rules[i] = selfValue
			} else {
				cr.initRecursiveRule(m, selfValue)
			}
		}
	}
}

func (r *R) Define(o *R) *R {
	r.recursive = true
	r.Alts = o.Alts
	for i := range r.Alts {
		r.Alts[i].R = r
	}
	return r
}

func (b *Builder) Con(rs ...interface{}) *R {
	return con(b.toRules(rs)...)
}

func con(rules ...*R) *R {
	if len(rules) == 1 {
		return rules[0]
	}
	r := NewRule()
	r.Alts = Alts{{r, rules}}
	return r
}

func (b *Builder) Or(rs ...interface{}) *R {
	return or(b.toRules(rs)...)
}
func or(rules ...*R) *R {
	if len(rules) == 1 {
		return rules[0]
	}
	r := NewRule()
	r.Alts = make(Alts, len(rules))
	for i := range rules {
		r.Alts[i] = rules[i].toAlt(r)
	}
	return r
}
func (r *R) toAlt(parent *R) *Alt {
	if len(r.Alts) == 1 && r.name == "" { // reduce unnamed rule
		return &Alt{parent, r.Alts[0].Rules}
	}
	return &Alt{parent, Rules{r}}
}

func (r *R) As(name string) *R {
	r.name = name
	return r
}

func (r *R) Optional() *R {
	return or(r, Null)
}

func (r *R) OneOrMore() *R {
	return con(r, r.zeroOrMore()) //.As(r.Name() + "+")
}

func (r *R) Repeat(limit ...int) *R {
	switch len(limit) {
	case 0:
		return r.zeroOrMore()
	case 1:
		n := limit[0]
		rs := make(Rules, n)
		for i := range rs {
			rs[i] = r
		}
		return con(rs...)
	case 2:
		lo, hi := limit[0], limit[1]
		if lo > hi {
			lo, hi = hi, lo
		}
		rs := make(Rules, 0, hi-lo+1)
		for n := lo; n <= hi; n++ {
			rs = append(rs, r.Repeat(n))
		}
		return or(rs...)
	}
	panic("repeat should have zero to two arguments")
}

func (r *R) zeroOrMore() *R {
	x := NewRule()
	//x.recursive = true
	x.Alts = or(con(r, x), Null).toAlts(x)
	x.As(r.Name() + "*")
	return x
}
func (r *R) toAlts(parent *R) Alts {
	r.eachAlt(func(a *Alt) {
		a.R = parent
	})
	return r.Alts
}

func (r *R) isEOF() bool {
	return r == EOF
}

func (r *R) isNull() bool {
	return r == Null
}

func (r *R) eachAlt(visit func(a *Alt)) {
	for _, a := range r.Alts {
		visit(a)
	}
}

func (a *Alt) last() *R {
	if len(a.Rules) > 0 {
		return a.Rules[len(a.Rules)-1]
	}
	return nil
}

func (a *Alt) isNull() bool {
	return len(a.Rules) == 1 && a.Rules[0].isNull()
}

func (a *Alt) rule() *R {
	return a.R
}

package parse

/*
1. Nested rules are reduced as much as possible, but named rules are always kept.
2. An unnamed rule has a display name. If it is not recursive, its display name
   is its definition wrapped by parenthesis, otherwise, its display name is
   generated from its pointer address.
3. Rules generated by ZeroOrMore and OneOrMore are automatically named as r* and
   r+.
*/

//const noID = -42

var (
	EOF  = Term("EOF")
	Null = Term("Null")
	self = Term("")
)

func newR() *R {
	return &R{}
}

func Term(name string) *R {
	return newR().As(name)
}

func Rule(name string, rules ...*R) *R {
	r := Con(rules...)
	if r.name != "" {
		r = r.wrap()
	}
	r.initRecursiveRule(make(map[*R]bool), r)
	return r.As(name)
}
func (r *R) wrap() *R {
	nr := newR()
	nr.Alts = Alts{{Parent: nr, Rules: Rules{r}}}
	return nr
}
func (r *R) initRecursiveRule(m map[*R]bool, selfValue *R) {
	if m[r] {
		r.recursive = true
		return
	}
	m[r] = true
	for _, alt := range r.Alts {
		if alt.Parent == self {
			alt.Parent = selfValue
		}
		for i, cr := range alt.Rules {
			if cr == self {
				alt.Rules[i] = selfValue
			} else {
				cr.initRecursiveRule(m, selfValue)
			}
		}
	}
}

func Self(name string) *R {
	self.name = name
	return self
}

func Con(rules ...*R) *R {
	if len(rules) == 1 {
		return rules[0]
	}
	r := newR()
	r.Alts = Alts{{r, rules}}
	return r
}

func Or(rules ...*R) *R {
	if len(rules) == 1 {
		return rules[0]
	}
	r := newR()
	r.Alts = make(Alts, len(rules))
	for i := range rules {
		r.Alts[i] = rules[i].toAlt(r)
	}
	return r
}
func (r *R) toAlt(parent *R) *Alt {
	if len(r.Alts) == 1 && r.name == "" { // reduce unnamed rule
		return &Alt{parent, r.Alts[0].Rules}
	}
	return &Alt{parent, Rules{r}}
}

func (r *R) As(name string) *R {
	r.name = name
	return r
}

func (r *R) ZeroOrOne() *R {
	return Or(r, Null)
}

func (r *R) OneOrMore() *R {
	return Con(r, r.ZeroOrMore()).As(r.Name() + "+")
}

func (r *R) ZeroOrMore() *R {
	x := newR()
	x.Alts = Or(Con(r, x), Null).toAlts(x)
	x.As(r.Name() + "*")
	return x
}
func (r *R) toAlts(parent *R) Alts {
	r.eachAlt(func(a *Alt) {
		a.Parent = parent
	})
	return r.Alts
}
